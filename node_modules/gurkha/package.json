{
  "name": "gurkha",
  "version": "2.0.3",
  "description": "Data extraction module",
  "main": "gurkha.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Finciero/gurkha.git"
  },
  "keywords": [
    "data",
    "extraction",
    "scraping"
  ],
  "author": {
    "name": "Jeremías Díaz Cordara",
    "email": "monitz87@gmail.com"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/Finciero/gurkha/issues"
  },
  "homepage": "https://github.com/Finciero/gurkha",
  "dependencies": {
    "cheerio": "^0.18.0"
  },
  "readme": "# gurkha\nData extraction module for Yakuza\n\n## Description\n\ngurkha is a simple data extraction tool designed to standarize html parsing. While it was thought with web scraping in mind, it can be used as a standalone tool. Let's say you have the following html table:\n\n| Product | Code | Price |\n|---------|------|-------|\n| Apple   | 2001 | $0.40 |\n| Orange  | 2002 | $0.44 |\n| Banana  | 2003 | $0.50 |\n\nLet's also say you wish to generate an array of 'product objects' like so:\n\n```javascript\n[{'name': 'Apple', 'code': '2001', 'price': '0.40'},\n {'name': 'Orange', 'code': '2002', 'price': '0.44'},\n {'name': 'Banana', 'code': '2003', 'price': '0.50'}]\n```\n\nWith gurkha, you just have to specify the object structure (called schema object) you desire, and a set of rules to indicate where in the html you can find the desired data for each object member. You can also specify post-processing functions to sanitize the data after it is retrieved (for example, if the price component of each object has to be stripped of the dollar signs). After that, you're just a function call away from your precious object array!\n\n## Usage\n\nConsidering the previous example, this is what the table html would look like:\n\n```html\n<html>\n  <table id='fruit'>\n    <thead>\n      <tr>\n        <td>Product</td>\n        <td>Code</td>\n        <td>Price</td>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>Apple</td>\n        <td>2001</td>\n        <td>$0.40</td>\n      </tr>\n      <tr>\n        <td>Orange</td>\n        <td>2002</td>\n        <td>$0.44</td>\n      </tr>\n      <tr>\n        <td>Banana</td>\n        <td>2003</td>\n        <td>$0.50</td>\n      </tr>\n    </tbody>\n  </table>\n</html>\n```\n\nAnd this is how you would parse it using gurkha:\n\n```javascript\nvar Gurkha = require('gurkha');\nvar gk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr',\n  'name': 'td:nth-child(1)',\n  'code': 'td:nth-child(2)',\n  'price': {\n    '$rule': 'td:nth-child(3)',\n    '$sanitizer': function ($elem) {\n      return $elem.text().replace(/\\$/, '');\n    }\n  }\n});\n\nvar products = gk.parse(someHtml);\n\nconsole.log(products[0].name);\n// 'Apple'\n```\n\ngurkha automatically detects whether the selection returns multiple elements and in that case, the value of that object member will be an array.\n\nYou can also pass an extra object to the Gurkha constructor if you need to modify any of the default parsing options and/or pass extra parameters to be used in the schema's functions. We will look into parameters in depth in another section. The syntax for the options object is the following:\n\n```javascript\n{\n  'options': {\n    // parsing options\n  },\n  'params': {\n    // parameters\n  }\n}\n```\n\nThese parsing options are taken directly from [htmlparser2](https://github.com/fb55/htmlparser2/wiki/Parser-options), therefore any options that can be used in `htmlparser2` are valid in cheerio as well. The default options are:\n\n```javascript\n{\n    normalizeWhitespace: false,\n    xmlMode: false,\n    decodeEntities: true\n}\n\n```\n\nThe result of a .parse() call will always be an array.\n\n## Smart Parsing\n\ngurkha is smart. You can instruct it to parse html into any kind of object structure. This includes nested objects and arrays, single values or an array of any mix of valid object structures. The only current limitation is that you cannot have dynamic object member names (they have to be predefined).\n\n### Nested Objects\n\nFollowing the previous example, let's say you wish to create a different structure, like so:\n\n```javascript\n[{\n  'fruit1:' {\n    'name': 'Apple',\n    'code': '2001',\n    'price': '$0.40'\n  },\n  'fruit2': {\n    'name': 'Orange',\n    'code': '2002',\n    'price': '$0.44'\n  },\n  'fruit3': {\n    'name': 'Banana',\n    'code': '2003',\n    'price': '$0.50'\n  }\n}]\n```\n\nYour schema object would then look something like this:\n\n```javascript\nvar gk = new Gurkha({\n  '$rule': 'table#fruit > tbody',\n  'fruit1': {\n    '$rule': 'tr:nth-child(1)',\n    'name': 'td:nth-child(1)',\n    'code': 'td:nth-child(2)',\n    'price': 'td:nth-child(3)'\n  },\n  'fruit2': {\n    '$rule': 'tr:nth-child(2)',\n    'name': 'td:nth-child(1)',\n    'code': 'td:nth-child(2)',\n    'price': 'td:nth-child(3)'\n  },\n  'fruit3': {\n    '$rule': 'tr:nth-child(3)',\n    'name': 'td:nth-child(1)',\n    'code': 'td:nth-child(2)',\n    'price': 'td:nth-child(3)'\n  }\n});\n```\n\nThis particular example is kind of redundant, but it shows how you can build infinitely nested objects with gurkha.\n\n### Nested Arrays\n\nLet's say you now just want your fruit data in array format, like so:\n\n```javascript\n[\n  {\n    'fruit': ['Apple', '2001', '$0.40']\n  },\n  {\n    'fruit': ['Orange', '2002', '$0.44']\n  },\n  {\n    'fruit': ['Banana', '2003', '$0.50']\n  }\n]\n```\n\nYour schema object would then look something like this:\n\n```javascript\ngk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr',\n  'fruit': [\n    'td:nth-child(1)',\n    'td:nth-child(2)',\n    'td:nth-child(3)'\n  ]\n});\n```\n\n### Single Array\n\nIf you just wished to get an array of the fruit names:\n\n```javascript\n['Apple', 'Orange', 'Banana']\n```\n\nYour schema object would then look something like this:\n\n```javascript\ngk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr > td:nth-child(1)'\n});\n```\n\n### String\n\nYou can pass a single selector to gurkha and it will return an array of the text attributes of all elements selected.\n\nSo this schema object\n\n```javascript\ngk = new Gurkha('table#fruit > tbody > tr > td:nth-child(1)');\n```\n\nwould return the same as the previous example, that is\n\n```javascript\n['Apple', 'Orange', 'Banana']\n```\n\n### Mixed Array\n\nYou can give gurkha an array of valid schema objects and it will yield an array of the results of parsing each of those objects separately! You can even nest these arrays and gurkha will follow suit.\n\nJust play around with the schema object and the selectors and you should be able to create just about any kind of structure you desire!\n\n## Options\n\ngurkha has a bunch of reserved keywords in the schema object to help you build your structure. This section will explain them in detail.\n\n### Rule\n\nThe '$rule' object member specifies the CSS selector that will retrieve the element in question. If absent, the selection will begin at the top level of the DOM.\n\nWhen a member of the schema object has a string for a value, the string value is implicitly bound to '$rule'.\n\n```javascript\n{\n  'name': 'table#fruit > tbody > tr > td:nth-child(1)'\n}\n```\n\nIs equivalent to\n\n```javascript\n{\n  'name': {\n    '$rule': 'table#fruit > tbody > tr > td:nth-child(1)'\n  }\n}\n```\n\nIt must be noted that nested '$rule' values are equivalent to a jquery .find() method.\n\nFor example, in this schema object\n\n```javascript\n{\n  '$rule': 'table#fruit > tbody > tr',\n  'name': {\n    '$rule': 'td:nth-child(1)'\n  }\n}\n```\n\nThe 'name' object member will be extracted using\n\n```javascript\n$('table#fruit > tbody > tr').find('td:nth-child(1)')\n```\n\nWhich is equivalent to concatenating the selectors.\n\nThis holds true to implicit rules, such as\n\n```javascript\n{\n  '$rule': 'table#fruit > tbody > tr',\n  'name': 'td:nth-child(1)'\n}\n```\n\nUse of '$rule' is optional, but not using it at the top level of the schema object will result on a performance hit.\n\nFor example, this is a perfectly valid schema object:\n\n```javascript\n{\n  'name': 'table#fruit > tbody > tr > td:nth-child(1)'\n}\n```\n\n### Sanitizing function\n\nThe '$sanitizer' object member specifies a sanitizing function to be applied to the data retrieved by the selector specified in '$rule'. It always receives a cheerio object representing the selected element as a parameter and must return the sanitized value. This is useful if you wish to perform any operations on the data, like removing special characters, trimming or even to continue traversing the DOM and retrieve other values to perform mixed operations.\n\nFor instance, a good use of '$sanitizer' would be to remove the dollar signs on the price of the fruit, like in the first example.\n\n'$sanitizer' will apply to the element selected by '$rule' only if the schema object of which it is a member has no unreserved object members. If there are unreserved members, '$sanitizer' will apply only to those which do not have unreserved members themselves. In other words, it will only apply to single-rule schema objects within the schema object where it is defined, so if you have this schema object\n\n```javascript\ngk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr',\n  '$sanitizer': function ($elem) {\n    return $elem.text() + ' gurkha rocks!';\n  },\n  'name': 'td:nth-child(1)',\n  'name2': {\n    '$rule': 'td:nth-child(1)'\n  },\n  'name-price': [\n    'td:nth-child(1)',\n    'td:nth-child(3)'\n  ],\n  'price-code': {\n    'code': 'td:nth-child(2)',\n    'price': 'td:nth-child(3)'\n  }\n});\n```\n\nthe sanitizing function will not propagate to the inner members of 'price-code', but will apply to 'name', 'name2' and 'name-price', yielding the following result:\n\n```javascript\n[ { name: 'Apple gurkha rocks!',\n    name2: 'Apple gurkha rocks!',\n    'name-price': [ 'Apple gurkha rocks!', '$0.40 gurkha rocks!' ],\n    'price-code': { code: '2001', price: '$0.40' } },\n  { name: 'Orange gurkha rocks!',\n    name2: 'Orange gurkha rocks!',\n    'name-price': [ 'Orange gurkha rocks!', '$0.44 gurkha rocks!' ],\n    'price-code': { code: '2002', price: '$0.44' } },\n  { name: 'Banana gurkha rocks!',\n    name2: 'Banana gurkha rocks!',\n    'name-price': [ 'Banana gurkha rocks!', '$0.50 gurkha rocks!' ],\n    'price-code': { code: '2003', price: '$0.50' } } ]\n```\n\nMoreover, inner sanitizing functions override outer ones in their scope.\n\n### Top level selection\n\nA schema object that has the '$topLevel' object member set to true will override '$rule' concatenation, meaning that it will select from the top level of the DOM. This is useful if the data you wish to extract is not all in one place.\n\nLet's continue with the example but add an anchor tab outside the table:\n\n```html\n<html>\n  <a href=\"https://www.npmjs.com/package/gurkha\">gurkha</a>\n  <table>\n    ...\n  </table>\n</html>\n```\n\nLet's say that for some reason, you wish your fruit objects to also have the link as a property. Your object array would look like this:\n\n```javascript\n[{'name': 'Apple', 'code': '2001', 'price': '0.40', link: 'https://www.npmjs.com/package/gurkha'},\n {'name': 'Orange', 'code': '2002', 'price': '0.44', link: 'https://www.npmjs.com/package/gurkha'},\n {'name': 'Banana', 'code': '2003', 'price': '0.50', link: 'https://www.npmjs.com/package/gurkha'}]\n```\n\nWith '$rule' concatenation, any selector you added to extract the 'link' attribute would start selecting from the rows of the table, yielding no results. Here is where you can use '$topLevel' to specify that the selection should start from the top level of the DOM.\n\nYour schema object would look like this\n\n```javascript\ngk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr',\n  'name': 'td:nth-child(1)',\n  'code': 'td:nth-child(2)',\n  'price': {\n    '$rule': 'td:nth-child(3)',\n    '$sanitizer': function ($elem) {\n      return $elem.text().replace(/\\$/, '');\n    }\n  },\n  'link': {\n    '$rule': 'a',\n    '$topLevel': true,\n    '$sanitizer': function ($elem) {\n      return $elem.attr('href');\n    }\n  }\n});\n```\n\n### Post-processing\n\nSometimes you may want to perform some post-processing operations on your object before gurkha returns it. You may even want to perform them on one of the inner objects in your master object.\n\nLet's take our first example and say that you wish to add the word 'Premium' at the beginning of the name of any fruit with a price of more than $0.42. Normally, you'd have to wait until gurkha returns your object and then pass it to a function that does this operation. With '$post', you may simply declare a function and gurkha will pass the object to that function before it returns it.\n\nYour schema object would look something like this:\n\n```javascript\nvar gk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr',\n  '$post': function (obj) {\n    if (obj.price > 0.42) {\n      obj.name = 'Premium ' + obj.name;\n    }\n\n    return obj;\n  },\n  'name': 'td:nth-child(1)',\n  'code': 'td:nth-child(2)',\n  'price': {\n    '$rule': 'td:nth-child(3)',\n    '$sanitizer': function ($elem) {\n      return $elem.text().replace(/\\$/, '');\n    }\n  }\n});\n``\n\nAnd the result would be\n\n```javascript\n[{'name': 'Apple', 'code': '2001', 'price': '0.40'},\n {'name': 'Premium Orange', 'code': '2002', 'price': '0.44'},\n {'name': 'Premium Banana', 'code': '2003', 'price': '0.50'}]\n```\n\nIt must be noted that post-processing functions must receive the object and return a value, so even if you just wish to perform operations on the object members, you must return the object at the end.\n\nAs you might expect, you can define post-processing functions for inner objects in your schema. For example, let's say you have this object structure\n\n```javascript\n{\n  'names': [\n    'Apple',\n    'Orange',\n    'Banana'\n  ],\n  'price-codes': [\n    {\n      'price': '$0.40',\n      'code': '2001'\n    },\n    {\n      'price': '$0.44',\n      'code': '2002'\n    },\n    {\n      'price': '$0.50',\n      'code': '2003'\n    }\n  ]\n}\n```\n\nbut you wish to compress both price and code into a single value (i.e. '0.40-2001'). You can accomplish this with '$post' in the following way:\n\n```javascript\ngk = new Gurkha({\n  'names': 'table#fruit > tbody > tr > td:nth-child(1)',\n  'price-codes': {\n    '$rule': 'table#fruit > tbody > tr',\n    '$post': function (obj) {\n      return obj.price + '-' + obj.code;\n    },\n    'price': 'td:nth-child(3)',\n    'code': 'td:nth-child(2)'\n  }\n});\n```\n\nand the result would be\n\n```javascript\n{\n  'names': [\n    'Apple',\n    'Orange',\n    'Banana'\n  ],\n  'price-codes': [\n    '$0.40-2001',\n    '$0.44-2002',\n    '$0.50-2003'\n  ]\n}\n```\n\nBe mindful that post-processing functions apply over each element of the object array, so you cannot post-process the entire array.\n\n### Filters\n\nLet's say you want gurkha to ignore any rows with the word 'Apple' in them. You could use the :nth-child pseudo selector, but there is a better way. Gurkha now supports filtering functions. A filtering function is a simple function which receives a cheerio object as an argument and returns true if that element should be filtered out. For instance, for this particular example, your schema object would look like this:\n\n```javascript\nvar gk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr',\n  'name': 'td:nth-child(1)',\n  'code': 'td:nth-child(2)',\n  'price': {\n    '$rule': 'td:nth-child(3)',\n    '$sanitizer': function ($elem) {\n      return $elem.text().replace(/\\$/, '');\n    }\n  },\n  '$ignore: function ($elem) {\n    return $elem.text().indexOf('Apple') > -1;\n  }'\n});\n```\n\nand the result would of course be:\n\n```javascript\n[{'name': 'Orange', 'code': '2002', 'price': '0.44'},\n {'name': 'Banana', 'code': '2003', 'price': '0.50'}]\n```\n\n### Constants\n\nSometimes not all of your desired object members are obtained via parsing. Sometimes you want your parsed object to contain some constant values. Let's say you wish to add a setter method for the ever fluctuating prices of fruit. You could always simply add it to the object with a post-processing function, or a sanitizer function that returns said function, but there is an easier and more readable way. Enter the 'constant' option:\n\n```javascript\nvar gk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr',\n  'name': 'td:nth-child(1)',\n  'code': 'td:nth-child(2)',\n  'price': {\n    '$rule': 'td:nth-child(3)',\n    '$sanitizer': function ($elem) {\n      return $elem.text().replace(/\\$/, '');\n    }\n  },\n  'setPrice': {\n    '$constant': function (val) {\n      this.price = val;\n    }\n  }\n});\n```\n\nBy using the 'constant' option, you are specifying that any preceding rules are to be ignored and that the result of parsing with that schema object will be whichever value its '$constant' member has. Be mindful that if '$constant' is set, any other options on that schema object are ignored, including post-processing functions.\n\n## Parameters\n\nAs it was mentioned in the introduction, you can pass parameters to the gurkha constructor along with the parsing options. These parameters are meant to be used by the sanitizer, filter and post-processing functions. Here are a couple of use cases that will illustrate how you can use parameters to your benefit.\n\nLet's take the first example and say you wish to convert the price to another currency, but the specific currency conversion rate you wish to use is dynamic. You could of course define the schema within the scope of your currency conversion variable, but there is a better, more readable way.\n\nFirst, you set up your schema like so:\n\n```javascript\nvar mySchema = {\n  '$rule': 'table#fruit > tbody > tr',\n  'name': 'td:nth-child(1)',\n  'code': 'td:nth-child(2)',\n  'price': {\n    '$rule': 'td:nth-child(3)',\n    '$sanitizer': function ($elem, params) {\n      return $elem.text().replace(/\\$/, '') * params.conversionRate;\n    }\n  }\n};\n```\n\nAnd then you simply pass the gurkha constructor an options object which contains your conversion rate as a parameter, like this:\n\n```javascript\nvar gk = new Gurkha(mySchema,\n{\n  'params': {\n    'conversionRate': someRate // defined elsewhere\n  }\n});\n```\n\nThe params object will be passed to every sanitizing function in the schema object, no matter how nested it is.\n\nIn another example, let's say you now wish to keep the original price but add a function to your object that logs out the converted price to the console. You could achieve this with parameters and the post-processing function.\n\nThis is how the constructor call would look like:\n\n```javascript\nvar gk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr',\n  'name': 'td:nth-child(1)',\n  'code': 'td:nth-child(2)',\n  'price': {\n    '$rule': 'td:nth-child(3)',\n    '$sanitizer': function ($elem) {\n      return $elem.text().replace(/\\$/, '');\n    }\n  },\n  '$post': function (obj, params) {\n    obj.printConvertedPrice = function () {\n      console.log(this.price * params.conversionRate);\n    };\n\n    return obj;\n  }\n},\n{\n  'params': {\n    'conversionRate': someRate // defined elsewhere\n  }\n});\n```\n\nAs with the sanitizers, the params object is also passed to every post-processing function in the schema object.\n\nFinally, let's say you wish to filter out all rows that contain a certain string of text, but this text is also dynamic.\n\nThis is how the constructor call would look like:\n\n```javascript\nvar gk = new Gurkha({\n  '$rule': 'table#fruit > tbody > tr',\n  'name': 'td:nth-child(1)',\n  'code': 'td:nth-child(2)',\n  'price': {\n    '$rule': 'td:nth-child(3)',\n    '$sanitizer': function ($elem) {\n      return $elem.text().replace(/\\$/, '');\n    }\n  },\n  '$ignore': function ($elem, params) {\n    return $elem.text().indexOf(params.forbiddenText) > -1;\n  }\n},\n{\n  'params': {\n    'forbiddenText': someText // defined elsewhere\n  }\n});\n```\n\nAs before, the params object is passed to every filtering function in the schema object.\n\nSince you can only pass a single params object to the gurkha constructor, it is shared among all functions in the schema. This allows you to mix-and-match.\n\nAs a final note, parameters passed to the constructor can be overriden by passing a new params object to a .parse() call.\n\n## Contributing\n\nIf you wish to contribute to this module, feel free to branch out from the development branch, I'll be glad to go over your contributions and add them if they're reasonable. Please test your code before sending in a pull request. Feel free to write any tests you need to check new functionality you wish to add. All tests are written using [jasmine-node](https://github.com/mhevery/jasmine-node \"jasmine-node\"). Any requests for features or bug fixes can be made by adding a new issue.\n",
  "readmeFilename": "README.md",
  "gitHead": "1dd31992e809d93ed82bcdf5466a80bab1664b24",
  "_id": "gurkha@2.0.3",
  "_shasum": "755e5e388a7a2934316b32ea8081cdd28f5cc7eb",
  "_from": "gurkha@>=2.0.3 <3.0.0"
}
